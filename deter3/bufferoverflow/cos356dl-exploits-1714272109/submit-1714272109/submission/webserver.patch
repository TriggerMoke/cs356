--- webserver.orig.c	2024-04-26 05:01:38.657833212 +0000
+++ webserver.c	2024-04-28 01:28:49.921224385 +0000
@@ -36,10 +36,10 @@
 #define _XOPEN_SOURCE
 
 typedef struct {
-	char *method;
-	char *uri;
-	char *version;
-	char *headers;
+        char *method;
+        char *uri;
+        char *version;
+        char *headers;
 } httpreq_t;
 
 
@@ -49,471 +49,500 @@
    function similar to the one below as a portable equivalent.
  */
 time_t my_timegm(struct tm *tm) {
-	time_t ret;
-	char *tz;
+        time_t ret;
+        char *tz;
 
-	tz = getenv("TZ");
-	putenv("TZ=GMT");
-	tzset();
-	ret = mktime(tm);
-	if (tz) {
-		char envstr[strlen(tz) + 4];
-		envstr[0] = '\0';
-		strcat(envstr, "TZ=");
-		strcat(envstr, tz);
-		putenv(envstr);
-	} else {
-		putenv("TZ=");
-	}
+        tz = getenv("TZ");
+        putenv("TZ=GMT");
+        tzset();
+        ret = mktime(tm);
+        if (tz) {
+                char envstr[strlen(tz) + 4];
+                envstr[0] = '\0';
+                strcat(envstr, "TZ=");
+                strcat(envstr, tz);
+                putenv(envstr);
+        } else {
+                putenv("TZ=");
+        }
 
-	tzset();
+        tzset();
 
-	return ret;
+        return ret;
 }
 
 char *get_header(const httpreq_t *req, const char* headername) {
-	char *hdrptr;
-	char *hdrend;
-	char *retval = NULL;
-
-	char searchstr[strlen(headername) + 5];
-	strcpy(searchstr, "\r\n");
-	strcat(searchstr, headername);
-	strcat(searchstr, ": ");
-
-	if (hdrptr = strstr(req->headers, searchstr)) { 
-		hdrptr += strlen(searchstr); 
-		if (hdrend = strstr(hdrptr, "\r\n")) { 
-			char hdrval[1024]; // temporary return value
-			memcpy((char *)hdrval, hdrptr, (hdrend - hdrptr));
-			hdrval[hdrend - hdrptr] = '\0'; // tack null onto end of header value
-			int hdrvallen = strlen(hdrval);
-			retval = (char *)malloc((hdrvallen + 1) * sizeof(char)); // malloc a space for retval
-			strcpy(retval, (char *)hdrval);
-		} else {
-			retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(char)); //
-			strcpy(retval, hdrptr);
-		}
-	}
+        char *hdrptr;
+        char *hdrend;
+        char *retval = NULL;
+
+        char searchstr[strlen(headername) + 5];
+        strcpy(searchstr, "\r\n");
+        strcat(searchstr, headername);
+        strcat(searchstr, ": ");
+
+        if (hdrptr = strstr(req->headers, searchstr)) { 
+                hdrptr += strlen(searchstr); 
+                if (hdrend = strstr(hdrptr, "\r\n")) { 
+                        char hdrval[1024]; // temporary return value
+                        memcpy((char *)hdrval, hdrptr, (hdrend - hdrptr));
+                        hdrval[hdrend - hdrptr] = '\0'; // tack null onto end of header value
+                        int hdrvallen = strlen(hdrval);
+                        retval = (char *)malloc((hdrvallen + 1) * sizeof(char)); // malloc a space for retval
+                        strcpy(retval, (char *)hdrval);
+                } else {
+                        retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(char)); //
+                        strcpy(retval, hdrptr);
+                }
+        }
 
-	return retval;
+        return retval;
 }
 
 /* As long as str begins with a proper HTTP-Version followed by delim, returns a
    pointer to the start of the version number (e.g., 1.0). Returns NULL otherwise.
  */
 char *http_version_str(char *str, char *delim) {
-	char *vstart = strstr(str, "HTTP/");
-	char *vnumstart = str + 5;
-	char *vdot = strchr(str, '.');
-	char *vend = strstr(str, delim);
-	char *digits = "0123456789";
-	int majvlen = 0;
-	int minvlen = 0;
-
-	if (!vstart || !vdot // something's missing
-		|| vstart != str) // str doesn't start with "HTTP/"
-		return NULL;
-
-	majvlen = strspn(vnumstart, digits);
-	minvlen = strspn(vdot + 1, digits);
-
-	if (majvlen < 1 || (vnumstart + majvlen) != vdot // bad major version
-		|| minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor version
-		return NULL;
+        char *vstart = strstr(str, "HTTP/");
+        char *vnumstart = str + 5;
+        char *vdot = strchr(str, '.');
+        char *vend = strstr(str, delim);
+        char *digits = "0123456789";
+        int majvlen = 0;
+        int minvlen = 0;
+
+        if (!vstart || !vdot // something's missing
+                || vstart != str) // str doesn't start with "HTTP/"
+                return NULL;
+
+        majvlen = strspn(vnumstart, digits);
+        minvlen = strspn(vdot + 1, digits);
+
+        if (majvlen < 1 || (vnumstart + majvlen) != vdot // bad major version
+                || minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor version
+                return NULL;
 
-	return vnumstart;
+        return vnumstart;
 }
 
 /* Fills req with the request data from datastr. Returns 0 on success.
  */
 
 int parsereq(httpreq_t *req, char *datastr) {
-	char *position;
-	char *last_position = datastr;
-	char *temp_position;
-	int matchlen;
-
-	req->method = "";
-	req->uri = "";
-	req->version = "";
-	req->headers = "";
-
-	if (!(position = strchr(last_position, ' '))) {
-		return 1;
-	}
-	matchlen = (int)(position - last_position);
-	req->method = (char *)malloc((matchlen + 1) * sizeof(char));
-	memcpy(req->method, last_position, matchlen);
-	req->method[matchlen] = '\0';
-	last_position = position + 1;
-
-	if (!(position = strchr(last_position, ' '))
-		&& !(position = strstr(last_position, "\r\n"))) {
-		return 1;
-	}
-
-	// strip any query string out of the URI
-	if ((temp_position = strchr(last_position, '?')) && temp_position < position)
-		matchlen = (int)(temp_position - last_position);
-	else
-		matchlen = (int)(position - last_position);
-
-	req->uri = (char *)malloc((matchlen + 1) * sizeof(char));
-	memcpy(req->uri, last_position, matchlen);
-	req->uri[matchlen] = '\0';
-	if (position[0] == '\r') {
-		req->version = "0.9";
-		req->headers = "";
-		return 0; // simple req -- uri only
-	}
-
-	// If we get here, it's a full request, get the HTTP version and headers
-	last_position = position + 1;
-
-	if (!(position = strstr(last_position, "\r\n"))
-		|| !(last_position = http_version_str(last_position, "\r\n"))) {
-		return 1;
-	}
-
-	matchlen = (int)(position - last_position);
-	req->version = (char *)malloc((matchlen + 1) * sizeof(char));
-	memcpy(req->version, last_position, matchlen);
-	req->version[matchlen] = '\0';
-	last_position = position;
+        char *position;
+        char *last_position = datastr;
+        char *temp_position;
+        int matchlen;
+
+        req->method = "";
+        req->uri = "";
+        req->version = "";
+        req->headers = "";
+
+        if (!(position = strchr(last_position, ' '))) {
+                return 1;
+        }
+        matchlen = (int)(position - last_position);
+        req->method = (char *)malloc((matchlen + 1) * sizeof(char));
+        memcpy(req->method, last_position, matchlen);
+        req->method[matchlen] = '\0';
+        last_position = position + 1;
+
+        if (!(position = strchr(last_position, ' '))
+                && !(position = strstr(last_position, "\r\n"))) {
+                return 1;
+        }
+
+        // strip any query string out of the URI
+        if ((temp_position = strchr(last_position, '?')) && temp_position < position)
+                matchlen = (int)(temp_position - last_position);
+        else
+                matchlen = (int)(position - last_position);
+
+        req->uri = (char *)malloc((matchlen + 1) * sizeof(char));
+        memcpy(req->uri, last_position, matchlen);
+        req->uri[matchlen] = '\0';
+        if (position[0] == '\r') {
+                req->version = "0.9";
+                req->headers = "";
+                return 0; // simple req -- uri only
+        }
+
+        // If we get here, it's a full request, get the HTTP version and headers
+        last_position = position + 1;
+
+        if (!(position = strstr(last_position, "\r\n"))
+                || !(last_position = http_version_str(last_position, "\r\n"))) {
+                return 1;
+        }
+
+        matchlen = (int)(position - last_position);
+        req->version = (char *)malloc((matchlen + 1) * sizeof(char));
+        memcpy(req->version, last_position, matchlen);
+        req->version[matchlen] = '\0';
+        last_position = position;
 
-	req->headers = (char *)malloc(strlen(last_position) * sizeof(char));
-	strcpy(req->headers, last_position);
+        req->headers = (char *)malloc(strlen(last_position) * sizeof(char));
+        strcpy(req->headers, last_position);
 
-	return 0;
+        return 0;
 } 
 
 char *contype(char *ext) {
-	if (strcmp(ext, "html") == 0) return "text/html";
-	else if (strcmp(ext, "htm") == 0) return "text/html";
-	else if (strcmp(ext, "jpeg") == 0) return "image/jpeg";
-	else if (strcmp(ext, "jpg") == 0) return "image/jpeg";
-	else if (strcmp(ext, "gif") == 0) return "image/gif";
-	else if (strcmp(ext, "txt") == 0) return "text/plain";
-	else return "application/octet-stream";
+        if (strcmp(ext, "html") == 0) return "text/html";
+        else if (strcmp(ext, "htm") == 0) return "text/html";
+        else if (strcmp(ext, "jpeg") == 0) return "image/jpeg";
+        else if (strcmp(ext, "jpg") == 0) return "image/jpeg";
+        else if (strcmp(ext, "gif") == 0) return "image/gif";
+        else if (strcmp(ext, "txt") == 0) return "text/plain";
+        else return "application/octet-stream";
 
 }
 
 char *status(int statcode) {
-	if (statcode == 200) 	return "200 OK";
-	else if (statcode == 304) return "304 Not Modified";
-	else if (statcode == 400) return "400 Bad Request";
-	else if (statcode == 403) return "403 Forbidden";
-	else if (statcode == 404) return "404 Not Found";
-	else if (statcode == 500) return "500 Internal Server Error";
-	else if (statcode == 501) return "501 Not Implemented";
-	else return "";
+        if (statcode == 200)    return "200 OK";
+        else if (statcode == 304) return "304 Not Modified";
+        else if (statcode == 400) return "400 Bad Request";
+        else if (statcode == 403) return "403 Forbidden";
+        else if (statcode == 404) return "404 Not Found";
+        else if (statcode == 500) return "500 Internal Server Error";
+        else if (statcode == 501) return "501 Not Implemented";
+        else return "";
+}
+
+
+void bufferAddChk(char **buffer, int *buffer_size, const char *data) {
+    // Check if there's enough space in the buffer
+    if (strlen(*buffer) + strlen(data) >= *buffer_size) {
+        // Calculate the new buffer size: either double the current size
+        // or the current size plus the size of the new data plus one, whichever is larger
+        int new_size = *buffer_size * 2;
+        if (new_size < *buffer_size + strlen(data) + 1) {
+            new_size = *buffer_size + strlen(data) + 1;
+        }
+        // Reallocate memory for the buffer
+        *buffer = realloc(*buffer, new_size);
+        // Check if the reallocation was successful
+        if (*buffer == NULL) {
+            // Handle the error (for example, by exiting the program)
+            perror("Error reallocating memory for buffer");
+            exit(EXIT_FAILURE);
+        }
+        // Update the buffer size
+        *buffer_size = new_size;
+    }
+    // Add the data to the buffer
+    strcat(*buffer, data);
 }
 
 int send_response(int sockfd, httpreq_t *req, int statcode) {
-	int urifd;
-	const int BUFSIZE = 1024;
-	char sendmessage[BUFSIZE];
-	char *path = req->uri;
-
-	if (req->uri == NULL || req->method == NULL || 
-		req->headers == NULL || req->version == NULL) {
-		return 0;
-	}
-
-
-	if ((path[0] == '/') || ((strstr(path, "http://") == path)
-							 && (path = strchr(path + 7,  '/')))) {
-		path += 1; // remove leading slash
-		if (path[0] == '\0') {  // substituting in index.html for a blank URL!
-			path = "index.html";
-		} else if (path[strlen(path) - 1] == '/') {
-			//concatenating index.html for a /-terminated URL!
-			strcat(path, "index.html");    
-		}
-	} else {
-		statcode = 400;
-	}
-
-	if (statcode == 200 && (urifd = open(path, O_RDONLY, 0)) < 0) {
-		if (errno == ENOENT || errno == ENOTDIR) { // file or directory doesn't exist
-			statcode = 404;
-		} else if (errno == EACCES) { // access denied
-			statcode = 403;
-		} else {
-			// some other file access problem
-			statcode = 500;
-		}
-	}
-
-	if (strstr(path, "..") != NULL) {
-		statcode = 500;
-	}
-
-
-	sendmessage[0] = '\0';
-	if (strcmp(req->version, "0.9") != 0) { // full request
-		char *ext; // file extension
-		time_t curtime;
-		char *imstime;
-		struct tm tm;
-		struct stat stbuf;
-
-
-		if (statcode == 200) {
-			if (ext = strrchr(path, '.')) ext++; // skip the '.'
-			else ext = "";
-		} else {
-			// errors are always html messages
-			ext = "html";
-		}
-
-		// Conditional GET
-		if ((strcmp(req->method, "GET") == 0)
-			&& (statcode == 200)
-			&& (imstime = get_header(req, "If-Modified-Since"))) {
-
-			// Get statistics about the requested URI from the local filesystem
-			if (stat(path, &stbuf) == -1) {
-				statcode = 500;
-			}
-
-			if (!strptime(imstime, "%a, %d %b %Y %H:%M:%S GMT", &tm)
-				&& !strptime(imstime, "%a, %d-%b-%y %H:%M:%S GMT", &tm)
-				&& !strptime(imstime, "%a %b %d %H:%M:%S %Y", &tm)) {
-				// badly formatted date
-				statcode = 400;
-			}
-
-			if (stbuf.st_mtime <= my_timegm(&tm)) {
-				// Not Modified
-				statcode = 304;
-			}
-		}
-
-		time(&curtime); // time for Date: header
-		strcat(sendmessage, "HTTP/1.0 ");
-		strcat(sendmessage, status(statcode));    
-		strcat(sendmessage, "\r\nDate: ");
-		strncat(sendmessage, asctime(gmtime(&curtime)), 24);
-		strcat(sendmessage, "\r\nServer: Frobozz Magic Software Company Webserver v.002");
-		strcat(sendmessage, "\r\nConnection: close");
-		strcat(sendmessage, "\r\nContent-Type: ");    
-		strcat(sendmessage, contype(ext));
-		strcat(sendmessage, "\r\n\r\n");
-
-	}
-
-	if (statcode != 200) {
-		strcat(sendmessage, "<html><head><title>");
-		strcat(sendmessage, status(statcode));
-		strcat(sendmessage, "</title></head><body><h2>HTTP/1.0</h2><h1>");
-		strcat(sendmessage, status(statcode));
-		strcat(sendmessage, "</h1><h2>URI: ");
-		strcat(sendmessage, path);
-		strcat(sendmessage, "</h2></body></html>");
-	}
-
-	if (sendmessage[0] != '\0') {
-		// send headers as long as there are headers to send
-		if (send(sockfd, sendmessage, strlen(sendmessage), 0) < 0) {
-			perror("send");
-			pthread_exit(NULL);
-		}
-	}
-
-	if (statcode == 200 && (strcmp(req->method, "HEAD") != 0)) {
-		// send the requested file as long as there's no error and the
-		// request wasn't just for the headers
-		int readbytes;
-
-		while (readbytes = read(urifd, sendmessage, BUFSIZE)) {
-			if (readbytes < 0) {
-				perror("read");
-				pthread_exit(NULL);
-			}
-			if (send(sockfd, sendmessage, readbytes, 0) < 0) {
-				perror("send");
-				pthread_exit(NULL);
-			}
-		}
-	}
+        int urifd;
+        int bufsize = 1024;
+        char *sendmessage = (char *)malloc(bufsize * sizeof(char));
+        char *path = req->uri;
+
+        if (req->uri == NULL || req->method == NULL || 
+                req->headers == NULL || req->version == NULL) {
+                return 0;
+        }
+
+
+        if ((path[0] == '/') || ((strstr(path, "http://") == path)
+                                                         && (path = strchr(path + 7,  '/')))) {
+                path += 1; // remove leading slash
+                if (path[0] == '\0') {  // substituting in index.html for a blank URL!
+                        path = "index.html";
+                } else if (path[strlen(path) - 1] == '/') {
+                        //concatenating index.html for a /-terminated URL!
+                        strcat(path, "index.html");    
+                }
+        } else {
+                statcode = 400;
+        }
+
+        if (statcode == 200 && (urifd = open(path, O_RDONLY, 0)) < 0) {
+                if (errno == ENOENT || errno == ENOTDIR) { // file or directory doesn't exist
+                        statcode = 404;
+                } else if (errno == EACCES) { // access denied
+                        statcode = 403;
+                } else {
+                        // some other file access problem
+                        statcode = 500;
+                }
+        }
+
+        if (strstr(path, "..") != NULL) {
+                statcode = 500;
+        }
+
+
+        sendmessage[0] = '\0';
+        if (strcmp(req->version, "0.9") != 0) { // full request
+                char *ext; // file extension
+                time_t curtime;
+                char *imstime;
+                struct tm tm;
+                struct stat stbuf;
+
+
+                if (statcode == 200) {
+                        if (ext = strrchr(path, '.')) ext++; // skip the '.'
+                        else ext = "";
+                } else {
+                        // errors are always html messages
+                        ext = "html";
+                }
+
+                // Conditional GET
+                if ((strcmp(req->method, "GET") == 0)
+                        && (statcode == 200)
+                        && (imstime = get_header(req, "If-Modified-Since"))) {
+
+                        // Get statistics about the requested URI from the local filesystem
+                        if (stat(path, &stbuf) == -1) {
+                                statcode = 500;
+                        }
+
+                        if (!strptime(imstime, "%a, %d %b %Y %H:%M:%S GMT", &tm)
+                                && !strptime(imstime, "%a, %d-%b-%y %H:%M:%S GMT", &tm)
+                                && !strptime(imstime, "%a %b %d %H:%M:%S %Y", &tm)) {
+                                // badly formatted date
+                                statcode = 400;
+                        }
+
+                        if (stbuf.st_mtime <= my_timegm(&tm)) {
+                                // Not Modified
+                                statcode = 304;
+                        }
+                }
+
+                time(&curtime); // time for Date: header
+                bufferAddChk(&sendmessage, &bufsize, "HTTP/1.0 ");
+                bufferAddChk(&sendmessage, &bufsize, status(statcode));   
+                bufferAddChk(&sendmessage, &bufsize, "\r\nDate: ");
+                char time_buffer[26];
+                strncpy(time_buffer, asctime(gmtime(&curtime)), 24);
+                time_buffer[24] = '\0'; // Ensure null termination
+                bufferAddChk(&sendmessage, &bufsize, time_buffer);
+                bufferAddChk(&sendmessage, &bufsize, "Frobozz Magic Software Company Webserver v.002");
+                bufferAddChk(&sendmessage, &bufsize, "\r\nConnection: close");
+                bufferAddChk(&sendmessage, &bufsize, "\r\nContent-Type: ");   
+                bufferAddChk(&sendmessage, &bufsize, contype(ext));
+                bufferAddChk(&sendmessage, &bufsize, "\r\n\r\n");
+
+        }
+
+        if (statcode != 200) {
+                bufferAddChk(&sendmessage, &bufsize, "<html><head><title>");
+                bufferAddChk(&sendmessage, &bufsize, status(statcode));
+                bufferAddChk(&sendmessage, &bufsize, "</title></head><body><h2>HTTP/1.0</h2><h1>");
+                bufferAddChk(&sendmessage, &bufsize, status(statcode));
+                bufferAddChk(&sendmessage, &bufsize, "</h1><h2>URI: ");
+                bufferAddChk(&sendmessage, &bufsize, path);
+                bufferAddChk(&sendmessage, &bufsize, "</h2></body></html>");
+        }
+
+        if (sendmessage[0] != '\0') {
+                // send headers as long as there are headers to send
+                if (send(sockfd, sendmessage, strlen(sendmessage), 0) < 0) {
+                        perror("send");
+                        pthread_exit(NULL);
+                }
+        }
+
+        if (statcode == 200 && (strcmp(req->method, "HEAD") != 0)) {
+                // send the requested file as long as there's no error and the
+                // request wasn't just for the headers
+                int readbytes;
+
+                while (readbytes = read(urifd, sendmessage, bufsize)) {
+                        if (readbytes < 0) {
+                                perror("read");
+                                pthread_exit(NULL);
+                        }
+                        if (send(sockfd, sendmessage, readbytes, 0) < 0) {
+                                perror("send");
+                                pthread_exit(NULL);
+                        }
+                }
+        }
+        free(sendmessage);
 }
 
 void *data_thread(void *sockfd_ptr) {
 
-	int sockfd = *(int *) sockfd_ptr;
-	const int BUFSIZE = 5;
-	char recvmessage[BUFSIZE];
-	char *headerstr = NULL;
-	char *newheaderstr = NULL;
-	int recvbytes = 0;
-	int curheadlen = 0;
-	int totalheadlen = 0;
-	httpreq_t req;
-	int statcode = 200;
-	int done = 0;
-	int seen_header = 0;
-	char *header_end;
-	int content_length = 0;
-	char *qstr;
+        int sockfd = *(int *) sockfd_ptr;
+        const int BUFSIZE = 5;
+        char recvmessage[BUFSIZE];
+        char *headerstr = NULL;
+        char *newheaderstr = NULL;
+        int recvbytes = 0;
+        int curheadlen = 0;
+        int totalheadlen = 0;
+        httpreq_t req;
+        int statcode = 200;
+        int done = 0;
+        int seen_header = 0;
+        char *header_end;
+        int content_length = 0;
+        char *qstr;
 
-	free(sockfd_ptr); // we have the int value out of this now
-	recvmessage[BUFSIZE - 1] = '\0'; // mark end of "string"
+        free(sockfd_ptr); // we have the int value out of this now
+        recvmessage[BUFSIZE - 1] = '\0'; // mark end of "string"
 
-	/* Read incoming client message from the socket */  
-	while(!done && (recvbytes = recv(sockfd, recvmessage, BUFSIZE - 1, 0))) {
-		if (recvbytes < 0) {
-			perror("recv");
-			pthread_exit(NULL);
-		}
+        /* Read incoming client message from the socket */  
+        while(!done && (recvbytes = recv(sockfd, recvmessage, BUFSIZE - 1, 0))) {
+                if (recvbytes < 0) {
+                        perror("recv");
+                        pthread_exit(NULL);
+                }
 
 
-		recvmessage[recvbytes] = '\0';
+                recvmessage[recvbytes] = '\0';
 
-		if (seen_header) {
-			// getting the entity body
-			content_length -= recvbytes;
-			if (content_length <= 0) done = 1;
+                if (seen_header) {
+                        // getting the entity body
+                        content_length -= recvbytes;
+                        if (content_length <= 0) done = 1;
 
-		} else {
+                } else {
 
-			newheaderstr = (char *) malloc((totalheadlen + recvbytes + 1) * sizeof(char));
-			newheaderstr[totalheadlen + recvbytes] = '\0';
-			memcpy(newheaderstr, headerstr, totalheadlen);
-			memcpy(newheaderstr + totalheadlen, recvmessage, recvbytes);
+                        newheaderstr = (char *) malloc((totalheadlen + recvbytes + 1) * sizeof(char));
+                        newheaderstr[totalheadlen + recvbytes] = '\0';
+                        memcpy(newheaderstr, headerstr, totalheadlen);
+                        memcpy(newheaderstr + totalheadlen, recvmessage, recvbytes);
 
-			if (headerstr != NULL) {
-				free(headerstr);
-			}
+                        if (headerstr != NULL) {
+                                free(headerstr);
+                        }
 
-			headerstr = newheaderstr;
-			totalheadlen += recvbytes;
+                        headerstr = newheaderstr;
+                        totalheadlen += recvbytes;
 
-			header_end = strstr(headerstr, "\r\n\r\n");
+                        header_end = strstr(headerstr, "\r\n\r\n");
 
-			if (header_end) {
-				seen_header = 1;
-				header_end[2] = '\0';
+                        if (header_end) {
+                                seen_header = 1;
+                                header_end[2] = '\0';
 
-				if (parsereq(&req, headerstr) != 0) {
-					statcode = 400;
-				}
+                                if (parsereq(&req, headerstr) != 0) {
+                                        statcode = 400;
+                                }
 
-				if (strcmp(req.method, "POST") == 0) {
+                                if (strcmp(req.method, "POST") == 0) {
 
-					// grab the body length
-					char *clenstr = get_header(&req, "Content-Length");
+                                        // grab the body length
+                                        char *clenstr = get_header(&req, "Content-Length");
 
-					if (clenstr) {
+                                        if (clenstr) {
 
-						content_length = atoi(clenstr) - ((headerstr + totalheadlen) - header_end - 4);
+                                                content_length = atoi(clenstr) - ((headerstr + totalheadlen) - header_end - 4);
 
-						if (content_length <= 0) {
-							done = 1;
-						}
+                                                if (content_length <= 0) {
+                                                        done = 1;
+                                                }
 
-						free(clenstr);
+                                                free(clenstr);
 
-					} else {
+                                        } else {
 
-						statcode = 400; // bad request -- no content length
-						done = 1;
-					}
+                                                statcode = 400; // bad request -- no content length
+                                                done = 1;
+                                        }
 
-				} else {
+                                } else {
 
-					// This isn't a POST, so there's no entity body
-					done = 1;
+                                        // This isn't a POST, so there's no entity body
+                                        done = 1;
 
-					if (strcmp(req.method, "GET") != 0
-						&& strcmp(req.method, "HEAD") != 0) {
+                                        if (strcmp(req.method, "GET") != 0
+                                                && strcmp(req.method, "HEAD") != 0) {
 
-						statcode = 501; // unknown request method
-					}
+                                                statcode = 501; // unknown request method
+                                        }
 
-				}
-			} // end of "if (header)end)"
-		}
-	} // end of recv while loop
+                                }
+                        } // end of "if (header)end)"
+                }
+        } // end of recv while loop
 
-	// used to deref a NULL pointer here... :(
-	if (headerstr != NULL) {
-		printf("%s\n", headerstr);
-		free(headerstr);
-	}
+        // used to deref a NULL pointer here... :(
+        if (headerstr != NULL) {
+                printf("%s\n", headerstr);
+                free(headerstr);
+        }
 
-	send_response(sockfd, &req, statcode);
-	close(sockfd);
+        send_response(sockfd, &req, statcode);
+        close(sockfd);
 
-	return NULL;
+        return NULL;
 
 }
 
 int main(int argc, char *argv[]) {
-	int acc, sockfd, clen, port;
-	struct hostent *he;
-	struct sockaddr_in caddr, saddr;
+        int acc, sockfd, clen, port;
+        struct hostent *he;
+        struct sockaddr_in caddr, saddr;
 
-	if(argc <= 1) {
+        if(argc <= 1) {
 
-		fprintf(stderr, "No port specified. Exiting!\n");
-		exit(1);
+                fprintf(stderr, "No port specified. Exiting!\n");
+                exit(1);
 
-	}
+        }
 
-	port = atoi(argv[1]);
+        port = atoi(argv[1]);
 
-	/* Obtain name and address for the local host */
-	if((he=gethostbyname("localhost"))==NULL) {
+        /* Obtain name and address for the local host */
+        if((he=gethostbyname("localhost"))==NULL) {
 
-		herror("gethostbyname");
-		exit(1);
+                herror("gethostbyname");
+                exit(1);
 
-	}
+        }
 
-	/* Open a TCP (Internet Stream) socket */
-	if((sockfd=socket(AF_INET,SOCK_STREAM,0)) == -1) {
+        /* Open a TCP (Internet Stream) socket */
+        if((sockfd=socket(AF_INET,SOCK_STREAM,0)) == -1) {
 
-		perror("socket");
-		exit(1);
+                perror("socket");
+                exit(1);
 
-	}
+        }
 
-	/* Create socket address structure for the local host */
-	memset((char *) &saddr, '\0', sizeof(saddr));
-	saddr.sin_family=AF_INET;
-	saddr.sin_port=htons(port);
-	saddr.sin_addr.s_addr=htonl(INADDR_ANY);
+        /* Create socket address structure for the local host */
+        memset((char *) &saddr, '\0', sizeof(saddr));
+        saddr.sin_family=AF_INET;
+        saddr.sin_port=htons(port);
+        saddr.sin_addr.s_addr=htonl(INADDR_ANY);
 
-	/* Bind our local address so that the client can send to us */
-	if(bind(sockfd,(struct sockaddr *) &saddr,sizeof(saddr)) == -1) {  
-		perror("bind");
-		exit(1);
-	}
+        /* Bind our local address so that the client can send to us */
+        if(bind(sockfd,(struct sockaddr *) &saddr,sizeof(saddr)) == -1) {  
+                perror("bind");
+                exit(1);
+        }
 
-	if(listen(sockfd,5) < 0) {
-		perror("listen");
-		exit(1);
-	}
+        if(listen(sockfd,5) < 0) {
+                perror("listen");
+                exit(1);
+        }
 
-	/* Infinite loop for receiving and processing client requests */
-	for(;;) {
-		clen=sizeof(caddr);
+        /* Infinite loop for receiving and processing client requests */
+        for(;;) {
+                clen=sizeof(caddr);
 
-		/* Wait for a connection for a client process */
-		acc=accept(sockfd,(struct sockaddr *) &caddr,(socklen_t*)&clen);
-		if(acc < 0) {
-			perror("accept");
-			exit(1);
-		} else {
-			pthread_t *thread = (pthread_t *) malloc(sizeof(pthread_t));
-			int *sockfd_ptr = (int *) malloc(sizeof(int));
+                /* Wait for a connection for a client process */
+                acc=accept(sockfd,(struct sockaddr *) &caddr,(socklen_t*)&clen);
+                if(acc < 0) {
+                        perror("accept");
+                        exit(1);
+                } else {
+                        pthread_t *thread = (pthread_t *) malloc(sizeof(pthread_t));
+                        int *sockfd_ptr = (int *) malloc(sizeof(int));
 
-			*sockfd_ptr = acc;
-			pthread_create(thread, NULL, data_thread, sockfd_ptr);
-		}
-	}
+                        *sockfd_ptr = acc;
+                        pthread_create(thread, NULL, data_thread, sockfd_ptr);
+                }
+        }
 
-	return 0;
+        return 0;
 }
